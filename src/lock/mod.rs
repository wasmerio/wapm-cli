pub mod lockfile;
pub mod lockfile_command;
pub mod lockfile_module;

pub static LOCKFILE_NAME: &str = "wapm.lock";

static LOCKFILE_HEADER: &str =
    "# This file is automatically generated by Wapm.\n# It is not intended for manual editing.";

use crate::dependency_resolver::PackageRegistry;
pub use crate::lock::lockfile::Lockfile;
pub use crate::lock::lockfile_command::LockfileCommand;
pub use crate::lock::lockfile_module::LockfileModule;
use crate::manifest::Manifest;
use std::env;
use std::path::Path;

#[inline]
pub fn get_package_namespace_and_name(package_name: &str) -> Result<(&str, &str), failure::Error> {
    let split: Vec<&str> = package_name.split('/').collect();
    match &split[..] {
        [namespace, name] => Ok((*namespace, *name)),
        [global_package_name] => Ok(("_", *global_package_name)),
        _ => bail!("Package name is invalid"),
    }
}

pub fn is_lockfile_out_of_date<P: AsRef<Path>>(directory: P) -> Result<bool, failure::Error> {
    use std::fs;
    let wapm_lock_metadata = fs::metadata(directory.as_ref().join("wapm.lock"))?;
    let wapm_toml_metadata = fs::metadata(directory.as_ref().join("wapm.toml"))?;
    let wapm_lock_last_modified = wapm_lock_metadata.modified()?;
    let wapm_toml_last_modified = wapm_toml_metadata.modified()?;
    Ok(wapm_lock_last_modified < wapm_toml_last_modified)
}

pub fn regenerate_lockfile(
    maybe_manifest: Result<Manifest, failure::Error>,
    maybe_lockfile: Result<Lockfile, failure::Error>,
    installed_dependencies: Vec<(&str, &str)>,
) -> Result<(), failure::Error> {
    let mut resolver = PackageRegistry::new();
    match (maybe_manifest, maybe_lockfile) {
        (Ok(mut manifest), Ok(existing_lockfile)) => {
            for (dependency_name, dependency_version) in installed_dependencies {
                manifest.add_dependency(dependency_name, dependency_version);
            }
            // construct lockfile
            let lockfile = Lockfile::new_from_manifest_and_lockfile(
                &manifest,
                existing_lockfile,
                &mut resolver,
            )?;
            // write the manifest
            manifest.save()?;
            // write the lockfile
            lockfile.save(&manifest.base_directory_path)?;
        }
        (Ok(mut manifest), Err(_lockfile_error)) => {
            for (dependency_name, dependency_version) in installed_dependencies {
                manifest.add_dependency(dependency_name, dependency_version);
            }
            // construct lockfile
            let lockfile = Lockfile::new_from_manifest(&manifest, &mut resolver)?;
            // write the manifest
            manifest.save()?;
            // write the lockfile
            lockfile.save(&manifest.base_directory_path)?;
        }
        (Err(_manifest_error), Ok(existing_lockfile)) => {
            let lockfile = Lockfile::new_from_lockfile_and_installed_dependencies(
                installed_dependencies,
                existing_lockfile,
                &mut resolver,
            )?;
            let cwd = env::current_dir()?;
            lockfile.save(&cwd)?;
        }
        (Err(_), Err(_)) => {
            let lockfile =
                Lockfile::new_from_installed_dependencies(installed_dependencies, &mut resolver)?;
            let cwd = env::current_dir()?;
            lockfile.save(&cwd)?;
        }
    }

    Ok(())
}
