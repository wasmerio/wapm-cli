use crate::abi::Abi;
use crate::dependency_resolver::DependencyResolver;
use crate::manifest::Manifest;
use std::collections::BTreeMap;
use std::fs::File;
use std::io::{Read, Write};
use std::path::Path;
use toml::Value;

pub static LOCKFILE_NAME: &str = "wapm.lock";

static LOCKFILE_HEADER: &str =
    "# This file is automatically generated by Wapm.\n# It is not intended for manual editing.";

/// Describes a command for a wapm module
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
pub struct LockfileCommand {
    pub module: String,
    emscripten_arguments: Option<String>,
}

#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
pub struct LockfileModule {
    pub name: String,
    pub version: String,
    pub source: String,
    pub resolved: String,
    pub integrity: String,
    pub hash: String,
    pub abi: Abi,
    pub entry: String,
}

#[derive(Debug, Deserialize, Serialize, PartialEq)]
pub struct Lockfile {
    pub modules: BTreeMap<String, LockfileModule>,
    pub commands: BTreeMap<String, LockfileCommand>,
}

impl Lockfile {
    pub fn open<P: AsRef<Path>>(directory: P) -> Result<Self, failure::Error> {
        let lockfile_path = directory.as_ref().join(LOCKFILE_NAME);
        let mut lockfile_file = File::open(lockfile_path)?;
        let mut lockfile_string = String::new();
        lockfile_file.read_to_string(&mut lockfile_string)?;
        let lockfile: Lockfile = toml::from_str(&lockfile_string)?;
        Ok(lockfile)
    }

    /// This function takes a manifest, maybe a lockfile, and a dependency resolver. The output is
    /// a new lockfile that resolves changes that have been made to the manifest file and the
    /// existing lockfile, if it exists. The resolver is used to fetch the manifest for packages
    /// that are new i.e. packages that have been added to the manifest and not been updated in
    /// the lockfile.
    pub fn new_from_manifest<D: DependencyResolver>(
        manifest: &Manifest,
        existing_lockfile: Option<Lockfile>,
        dependency_resolver: &D,
    ) -> Result<Self, failure::Error> {
        // get all dependencies that changed and references to unchanged lockfile modules
        let (changed_dependencies, unchanged_lockfile_modules) =
            resolve_changes(&manifest, existing_lockfile.as_ref())?;
        // get all (unchanged) commands for unchanged lockfile modules
        let mut lockfile_commands = BTreeMap::new();
        match existing_lockfile {
            Some(ref lockfile) => {
                let commands = &lockfile.commands;
                for (key, _lockfile_module) in unchanged_lockfile_modules.iter() {
                    for (name, command) in
                        commands.iter().filter(|(_name, c)| &c.module == key)
                    {
                        lockfile_commands.insert(name.clone(), command.clone());
                    }
                }
            }
            None => {}
        }
        // copy all lockfile modules into a map
        let mut lockfile_modules= unchanged_lockfile_modules;
        // for all changed dependencies, fetch the newest manifest
        for (name, version) in changed_dependencies {
            let dependency_manifest = dependency_resolver.resolve(&name, &version)?;
            let dependency_module = dependency_manifest.module.as_ref().unwrap();
            let key = format!("{} {}", name, version);
            let lockfile_module = LockfileModule {
                name: dependency_module.name.clone(),
                version: dependency_module.version.to_string(),
                source: format!("registry+{}", dependency_module.name),
                resolved: "".to_string(),
                integrity: "".to_string(),
                hash: "".to_string(),
                abi: dependency_module.abi.clone(),
                entry: dependency_module
                    .module
                    .file_name()
                    .unwrap()
                    .to_str()
                    .unwrap()
                    .to_string(),
            };
            lockfile_modules.insert(key, lockfile_module);

            match dependency_manifest.command {
                Some(ref commands) => {
                    for command in commands {
                        let module_string =
                            format!("{} {}", dependency_module.name, dependency_module.version);
                        let lockfile_command = LockfileCommand {
                            module: module_string,
                            emscripten_arguments: command.emscripten_call_arguments.clone(),
                        };
                        lockfile_commands.insert(command.name.clone(), lockfile_command);
                    }
                }
                None => {}
            };
        }

        // handle this manifest's commands
        match (&manifest.command, &manifest.module) {
            (Some(commands), Some(module)) => {
                for command in commands {
                    let module_string = format!("{} {}", module.name, module.version);
                    let lockfile_command = LockfileCommand {
                        module: module_string,
                        emscripten_arguments: command.emscripten_call_arguments.clone(),
                    };
                    lockfile_commands.insert(command.name.clone(), lockfile_command);
                }
            }
            (_, _) => {} // if there is no module, then there are no commands
        };

        let new_lockfile = Lockfile {
            modules: lockfile_modules,
            commands: lockfile_commands,
        };

        Ok(new_lockfile)
    }

    pub fn save<P: AsRef<Path>>(&self, directory: P) -> Result<(), failure::Error> {
        let lockfile_string = toml::to_string(self)?;
        let lockfile_string = format!("{}\n{}", LOCKFILE_HEADER, lockfile_string);
        let lockfile_path = directory.as_ref().join(LOCKFILE_NAME);
        let mut file = File::create(&lockfile_path)?;
        file.write_all(lockfile_string.as_bytes())?;
        Ok(())
    }
}

/// This helper function resolves differences between the lockfile and the manifest file. All changes
/// that have not been reflected in the lockfile are returned as a vec of package names and versions.
/// The packages that had no changes are returned as references to the the lockfile modules.
fn resolve_changes<'a, 'b>(
    manifest: &'b Manifest,
    lockfile: Option<&'a Lockfile>,
) -> Result<(Vec<(&'b String, &'b String)>, BTreeMap<String, LockfileModule>), failure::Error> {
    let (changes, not_changed) = match (lockfile, &manifest.dependencies) {
        (Some(lockfile), Some(ref dependencies)) => {
            let mut changes = vec![];
            let mut not_changed = BTreeMap::new();
            for (name, value) in dependencies.iter() {
                match value {
                    Value::String(version) => {
                        let key = format!("{} {}", name, version);
                        match lockfile.modules.get(&key) {
                            Some(lockfile_module) => {
                                not_changed.insert(key, lockfile_module.clone());
                            }
                            None => changes.push((name, version)),
                        }
                    }
                    _ => return Err(LockfileError::InvalidVersion.into()),
                }
            }
            (changes, not_changed)
        }
        (Some(_lockfile), None) => (vec![], BTreeMap::new()), // TODO no manifest but lockfile exists
        (None, Some(ref dependencies)) => {
            let mut changes = vec![];
            for (name, value) in dependencies.iter() {
                match value {
                    Value::String(version) => changes.push((name, version)),
                    _ => return Err(LockfileError::InvalidVersion.into()),
                }
            }
            (changes, BTreeMap::new())
        }
        (None, None) => (vec![],  BTreeMap::new()),
    };

    Ok((changes, not_changed))
}

#[derive(Debug, Fail)]
pub enum LockfileError {
    #[fail(display = "Version must be a string.")]
    InvalidVersion,
}

#[cfg(test)]
mod resolve_changes_tests {
    use crate::lockfile::{resolve_changes, Lockfile};
    use crate::manifest::Manifest;
    #[test]
    fn no_existing_lock_file_and_has_zero_dependencies() {
        let wapm_toml = toml! {
            [module]
            name = "test"
            version = "1.0.0"
            module = "target.wasm"
            description = "description"
        };
        let manifest: Manifest = wapm_toml.try_into().unwrap();
        let (changes, not_changed) = resolve_changes(&manifest, None).unwrap();
        assert_eq!(0, changes.len());
        assert_eq!(0, not_changed.len());
    }
    #[test]
    fn no_existing_lock_file_and_has_dependencies() {
        let wapm_toml = toml! {
            [module]
            name = "test"
            version = "1.0.0"
            module = "target.wasm"
            description = "description"
            [dependencies]
            foo = "1.0.0"
            bar = "2.0.1"
        };
        let manifest: Manifest = wapm_toml.try_into().unwrap();
        let (changes, not_changed) = resolve_changes(&manifest, None).unwrap();
        assert_eq!(2, changes.len());
        assert_eq!(0, not_changed.len());
    }
    #[test]
    fn lock_file_exists_and_one_unchanged_dependency() {
        let wapm_toml = toml! {
            [module]
            name = "test"
            version = "1.0.0"
            module = "target.wasm"
            description = "description"
            [dependencies]
            foo = "1.0.0"
            bar = "2.0.1"
        };
        let manifest: Manifest = wapm_toml.try_into().unwrap();
        let wapm_lock_toml = toml! {
            [modules."foo 1.0.0"]
            name = "foo"
            version = "1.0.0"
            source = ""
            resolved = ""
            integrity = ""
            hash = ""
            abi = "None"
            entry = "target.wasm"
            [modules."bar 3.0.0"]
            name = "bar"
            version = "3.0.0" // THIS CHANGED!
            source = ""
            resolved = ""
            integrity = ""
            hash = ""
            abi = "None"
            entry = "target.wasm"
            [commands]
        };
        let lockfile: Lockfile = wapm_lock_toml.try_into().unwrap();
        let lockfile = Some(&lockfile);

        let (changes, not_changed) = resolve_changes(&manifest, lockfile).unwrap();
        assert_eq!(1, changes.len()); // one dependency was upgraded
        assert_eq!(1, not_changed.len()); // one dependency did not change, reuse the lockfile module
    }
}

#[cfg(test)]
mod test {
    use crate::dependency_resolver::TestResolver;
    use crate::lockfile::{Lockfile, LOCKFILE_NAME};
    use crate::manifest::{Manifest, MANIFEST_FILE_NAME};
    use std::collections::BTreeMap;
    use std::fs::File;
    use std::io::Write;

    #[test]
    fn open_nonexistent_lockfile() {
        let tmp_dir = tempdir::TempDir::new("open_nonexistent_lockfile").unwrap();
        let lockfile_result = Lockfile::open(tmp_dir.as_ref());
        assert!(lockfile_result.is_err());
    }
    #[test]
    fn open_lockfile() {
        let tmp_dir = tempdir::TempDir::new("open_lockfile").unwrap();
        let wapm_lock_toml = toml! {
            [modules."test 1.0.0"]
            name = "test"
            version = "1.0.0"
            source = ""
            resolved = ""
            integrity = ""
            hash = ""
            abi = "None"
            entry = "source.wasm"

            [commands.foo]
            module = "foo@0.1.1"
        };
        let lock_path = tmp_dir.path().join(LOCKFILE_NAME);
        let mut file = File::create(&lock_path).unwrap();
        let toml_string = toml::to_string(&wapm_lock_toml).unwrap();
        file.write_all(toml_string.as_bytes()).unwrap();
        let _lockfile_result = Lockfile::open(tmp_dir.as_ref()).unwrap();
    }
    #[test]
    fn create_from_manifest() {
        let tmp_dir = tempdir::TempDir::new("create_from_manifest").unwrap();
        let wapm_toml = toml! {
            [module]
            name = "test"
            version = "1.0.0"
            module = "target.wasm"
            description = "description"
        };
        let manifest_path = tmp_dir.path().join(MANIFEST_FILE_NAME);
        let mut file = File::create(&manifest_path).unwrap();
        let toml_string = toml::to_string(&wapm_toml).unwrap();
        file.write_all(toml_string.as_bytes()).unwrap();
        let manifest = Manifest::open(manifest_path).unwrap();

        let resolver = TestResolver(BTreeMap::new());

        let lockfile = Lockfile::new_from_manifest(&manifest, None, &resolver).unwrap();
        assert_eq!(0, lockfile.commands.len());
        assert_eq!(0, lockfile.modules.len());
    }
    #[test]
    fn create_from_manifest_and_existing_lockfile_with_dependencies_and_commands() {
        let wapm_toml = toml! {
            [module]
            name = "test"
            version = "1.0.0"
            module = "target.wasm"
            description = "description"
            [dependencies]
            foo = "1.0.2"
            bar = "3.0.0"
        };
        let manifest: Manifest = wapm_toml.try_into().unwrap();

        // setup resolver
        let mut map = BTreeMap::new();
        // FOO package v 1.0.0
        let foo_toml: toml::Value = toml! {
            [module]
            name = "foo"
            version = "1.0.0"
            module = "foo.wasm"
            description = ""
            [[command]]
            name = "do_foo_stuff"
        };
        let foo_manifest: Manifest = foo_toml.try_into().unwrap();
        // FOO package v 1.0.2
        map.insert(("foo".to_string(), "1.0.2".to_string()), foo_manifest);
        let newer_foo_toml: toml::Value = toml! {
            [module]
            name = "foo"
            version = "1.0.2"
            module = "foo.wasm"
            description = ""
            [[command]]
            name = "do_more_foo_stuff" // COMMAND REMOVED AND ADDED
        };
        let newer_foo_manifest: Manifest = newer_foo_toml.try_into().unwrap();
        map.insert(("foo".to_string(), "1.0.2".to_string()), newer_foo_manifest);
        // BAR package v 2.0.1
        let bar_toml: toml::Value = toml! {
            [module]
            name = "bar"
            version = "2.0.1"
            module = "bar.wasm"
            description = ""
        };
        let bar_manifest: Manifest = bar_toml.try_into().unwrap();
        map.insert(("bar".to_string(), "2.0.1".to_string()), bar_manifest);
        // BAR package v 3.0.0
        let bar_newer_toml: toml::Value = toml! {
            [module]
            name = "bar"
            version = "3.0.0"
            module = "bar.wasm"
            description = ""
            [[command]]
            name = "do_bar_stuff" // ADDED COMMAND
        };
        let bar_newer_manifest: Manifest = bar_newer_toml.try_into().unwrap();
        map.insert(("bar".to_string(), "3.0.0".to_string()), bar_newer_manifest);
        let test_resolver = TestResolver(map);

        // existing lockfile
        let wapm_lock_toml = toml! {
            [modules."foo 1.0.0"]
            name = "foo"
            version = "1.0.0"
            source = "registry+foo"
            resolved = ""
            integrity = ""
            hash = ""
            abi = "None"
            entry = "foo.wasm"
            [modules."bar 2.0.1"]
            name = "bar"
            version = "2.0.1"
            source = "registry+bar"
            resolved = ""
            integrity = ""
            hash = ""
            abi = "None"
            entry = "bar.wasm"
            [commands.do_foo_stuff]
            module = "foo 1.0.0"
        };

        let existing_lockfile: Lockfile = wapm_lock_toml.try_into().unwrap();

        let lockfile =
            Lockfile::new_from_manifest(&manifest, Some(existing_lockfile), &test_resolver)
                .unwrap();

        // existing lockfile
        let expected_lock_toml = toml! {
            [modules."foo 1.0.2"]
            name = "foo"
            version = "1.0.2"
            source = "registry+foo"
            resolved = ""
            integrity = ""
            hash = ""
            abi = "None"
            entry = "foo.wasm"
            [modules."bar 3.0.0"]
            name = "bar"
            version = "3.0.0"
            source = "registry+bar"
            resolved = ""
            integrity = ""
            hash = ""
            abi = "None"
            entry = "bar.wasm"
            [commands.do_more_foo_stuff]
            module = "foo 1.0.2"
            [commands.do_bar_stuff]
            module = "bar 3.0.0"
        };

        let expected_lockfile: Lockfile = expected_lock_toml.try_into().unwrap();

        assert_eq!(expected_lockfile, lockfile);
    }
}
